#!/usr/bin/env python3
"""plot_cadence_power.py
usage: plot_cadence_power.py [-h] [--title TITLE] [-b] [-g GLOBAL_OFFSET] [--start START] [--stop STOP] [-c CUSTOM [CUSTOM ...]] [-a A_TRAINING_TRACKER [A_TRAINING_TRACKER ...]]
                             [-f FIT_FILES [FIT_FILES ...]]

Plots data from several power meters over time

options:
  -h, --help            show this help message and exit
  --title TITLE         Title to put on the figure (default: Comparison between power meters)
  -b, --balance         Plot the left-right power balance instead of calculating individual left-right power for each side. (default: False)

Time:
  Parameters relating to time offsets and limiting the time periods plotted.

  -g GLOBAL_OFFSET, --global-offset GLOBAL_OFFSET
                        Global time offset in seconds. This is mainly for making the x axis look nicer. The start and stop times also depend on this. (default: 0)
  --start START         The minimum time to show (after all offsets are applied). (default: None)
  --stop STOP           The maximum time to show (after all offsets are applied). (default: None)

Importers:
  Importers allow data in different formats to be processed.

  -c CUSTOM [CUSTOM ...], --custom CUSTOM [CUSTOM ...]
                        Folders containing data generated by log_power_meter.py. Data is formatted as a series of tuples of FOLDERNAME[,DISPLAY_NAME,OFFSET]]. If the display
                        name is not provided, the folder name will be used and the offset set to 0. The offset (in seconds) defaults to 0 if not specified. (default: None)
  -a A_TRAINING_TRACKER [A_TRAINING_TRACKER ...], --a-training-tracker A_TRAINING_TRACKER [A_TRAINING_TRACKER ...]
                        CSV file generated by the A Training Tracker App (or similar). Data is formatted as a series of sets of FOLDERNAME[,DISPLAY_NAME,[OFFSET]]. If the
                        display name is not provided, the file name will be used and the offset set to 0. The offset (in seconds) defaults to 0 if not specified. (default: None)
  -f FIT_FILES [FIT_FILES ...], --fit-files FIT_FILES [FIT_FILES ...]
                        FIT file to import. Data is formatted as a series of sets of FOLDERNAME[,DISPLAY_NAME,[OFFSET]]. If the display name is not provided, the folder name
                        will be used and the offset set to 0. The offset (in seconds) defaults to 0 if not specified. (default: None)

Written by Jotham Gates and Oscar Varney for MHP, 2024
"""
import pandas as pd
import numpy as np
from typing import Tuple, List, Union
from matplotlib.axes import Axes
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import argparse
from abc import ABC, abstractmethod
import datetime
from fit_tool.fit_file import FitFile
from fit_tool.profile.messages.record_message import RecordMessage

from common import add_time_args, none_empty_list

class Importer(ABC):
    """Base class for importing power and cadence data."""
    def __init__(self, name:str, offset:float): # , df:pd.DataFrame, offset:float):
        self.df = None
        self.name = name
        self.offset = offset
        self.scale = 1

    @abstractmethod
    def load(self) -> None:
        """Imports the data and applies the specified offset.
        Call self._load to apply the offset and save the frame."""
        pass
    
    
    def set_scale(self, scale:float) -> None:
        """Sets a scaling factor.

        Args:
            scale (float): The scalar to scale power by.
        """
        self.scale = scale

    def _load(self, df:pd.DataFrame) -> None:
        """Imports the data and applies the specified offset."""
        # Save and apply the time offset
        self.df = df
        self.df["Unix Timestamp [s]"] += self.offset

        self.df["Power [W]"] *= self.scale

        self.df["Left Power [W]"] = self.df["Balance [%]"] / 100 * self.df["Power [W]"]
        self.df["Right Power [W]"] = (100 - self.df["Balance [%]"]) / 100 * self.df["Power [W]"]

    def limit_times(self, start_time:Union[float, None], stop_time:Union[float, None]) -> None:
        """Limits the time to be between two points if needed.

        Args:
            importers (List[Importer]): The importers to apply this to.
            start_time (Union[float, None]): The start time. If None, no filtering of minimum times is applied.
            stop_time (Union[float, None]): The stop time. If None, no filtering of maximum times is applied.
        """
        if start_time is not None:
            self.df = self.df.drop(self.df[self.df["Unix Timestamp [s]"] < start_time].index)
        
        if stop_time is not None:
            self.df = self.df.drop(self.df[self.df["Unix Timestamp [s]"] > stop_time].index)

    def get_data(self) -> pd.DataFrame:
        """Returns the cadence over time.

        Returns:
            pd.DataFrame: Dataframe with at least columns
                          - "Unix Timestamp [s]"
                          - "Cadence [rpm]"
                          - "Power [W]"
                          - "Balance [%]"
        """
        if self.df is not None:
            return self.df
        else:
            raise ValueError("self.load() has not been called prior.")

class MHPCSVImporter(Importer):
    """Importer for logs generated by log_power_meter.py"""
    def __init__(self, folder:str, offset:float, name:str="Custom power meter"):
        super().__init__(name, offset)
        self.folder = folder
    
    def load(self) -> None:
        return self._load(pd.read_csv(f"{self.folder}/slow.csv"))

class ATrainingTrackerCSVImporter(Importer):
    """Importer for CSV files generated by the A Training Tracker app (and MHP's variant of it)."""
    def __init__(self, file:str, offset:float, name:str="A training tracker"):
        super().__init__(name, offset)
        self.file = file
    
    def load(self) -> None:
        imported_df = pd.read_csv(self.file)
        processed_df = pd.DataFrame({
            "Unix Timestamp [s]": self.convert_timestamps(imported_df["time"]),
            "Cadence [rpm]": imported_df["CADENCE"],
            "Power [W]": imported_df["POWER"],
            "Balance [%]": imported_df["PEDAL_POWER_BALANCE"]
        })
        return self._load(processed_df)

    def convert_timestamps(self, column:pd.Series) -> pd.Series:
        def str_to_unix(date_str:str) -> float:
            date = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S").replace(tzinfo=datetime.timezone.utc)
            timestamp = date.timestamp()
            return timestamp
        return column.apply(str_to_unix)

class FITImporter(Importer):
    """Imports FIT files"""
    def __init__(self, file:str, offset:float, name:str="TCX file"):
        super().__init__(name, offset=offset)
        self.file = file
    
    def load(self) -> None:
        fit_file = FitFile.from_file(self.file)
        records = fit_file.records
        timestamps = []
        power = []
        distance = []
        speed = []
        cadence = []
        balance = []
        for record in records:
            message = record.message
            if isinstance(message, RecordMessage):
                timestamps.append(message.timestamp)
                distance.append(message.distance)
                power.append(message.power)
                speed.append(message.speed)
                cadence.append(message.cadence)
                balance.append(message.left_right_balance)

        return self._load(pd.DataFrame({
            "Unix Timestamp [s]": np.array(timestamps) / 1000,
            "Cadence [rpm]": cadence,
            "Power [W]": power,
            "Balance [%]": balance
        }))

def offset_all(importers:List[Importer], offset:float) -> None:
    """Offsets all times on all importers by a given amount.

    Args:
        importers (List[Importer]): The importers to offset.
        offset (float): The amount to offset by.
    """
    for i in importers:
        i.df["Unix Timestamp [s]"] += offset

def plot_axes(axes:Axes, field:str, importers:List[Importer]) -> None:
    """Plots the data for all importers over an axes.

    Args:
        axes (Axes): Axes to plot on.
        field (str): Field to get from the importer.
        importers (List[Importer]): List of importers to plot.
    """
    for i in importers:
        data = i.get_data()
        axes.plot(data["Unix Timestamp [s]"].values, data[field].values, label=i.name)
    
    axes.grid()

def plot_graph(importers:List[Importer], title:str, show_balance:bool) -> None:
    """Plots strain over time.

    Args:
        left_df (pd.DataFrame): Left data
        right_df (pd.DataFrame): Right data
        title (str): The title to use.
    """
    # Create a figure with a raw subplot.
    fig = plt.figure()
    gs = fig.add_gridspec(3, height_ratios=[1, 1, 1])
    ax_cadence, ax_power, ax_balance = gs.subplots(sharex=True)
    ax_cadence:Axes
    ax_power:Axes
    ax_balance:Axes

    # Plot the cadence axes
    plot_axes(ax_cadence, "Cadence [rpm]", importers)
    ax_cadence.set_title("Cadence")
    ax_cadence.set_ylabel("Cadence [$rpm$]")
    ax_cadence.legend() #loc="upper center")

    # Plot the power axes
    plot_axes(ax_power, "Power [W]", importers)
    ax_power.set_title("Power")
    ax_power.set_ylabel("Power [$W$]")

    if show_balance:
        # Plot the power balance
        plot_axes(ax_balance, "Balance [%]", importers)
        ax_balance.set_title("Power balance between left and right sides (only capable power meters shown)")
        ax_balance.set_ylabel("Balance [%]")
    else:
        # Plot the power for each side.
        colour_cycle = plt.rcParams['axes.prop_cycle'].by_key()['color']
        for index, i in enumerate(importers):
            data = i.get_data()
            ax_balance.plot(data["Unix Timestamp [s]"].values, data["Left Power [W]"].values, "-", color=colour_cycle[index], label=f"{i.name} (left)")
            ax_balance.plot(data["Unix Timestamp [s]"].values, data["Right Power [W]"].values, ":", color=colour_cycle[index], label=f"{i.name} (right)")

        # Legend is needed (custom so we can just put the left and right sides without colours)
        left_line = Line2D([0], [0], linestyle="-", color="black")
        right_line = Line2D([0], [0], linestyle=":", color="black")
        legend_lines = [left_line, right_line]
        ax_balance.legend(legend_lines, ["Left side", "Right side"])

        # Other formatting.
        ax_balance.set_ylabel("Power [W]")
        ax_balance.set_title("Power measured on each side (only capable power meters shown)")
        ax_balance.grid()

    ax_balance.set_xlabel("Time [s]")

    # Overall formatting.
    plt.suptitle(title)
    # plt.tight_layout()
    plt.show()

def load_all(importers: List[Importer]) -> None:
    """Loads all data.

    Args:
        importers (List[Importer]): The importers to load.
    """
    for i in importers:
        i.load()

def truncate_times(importers: List[Importer], start_time:Union[float, None], stop_time:Union[float, None]) -> None:
    """Limits the time to be between two points if needed.

    Args:
        importers (List[Importer]): The importers to apply this to.
        start_time (Union[float, None]): The start time. If None, no filtering of minimum times is applied.
        stop_time (Union[float, None]): The stop time. If None, no filtering of maximum times is applied.
    """
    for i in importers:
        i.limit_times(start_time, stop_time)
        

def importer_name_pair(argument:str) -> Tuple[str, str]:
    """Parser for an importer.

    Args:
        argument (str): The input argument containing the filename and optionally the name to show, separated by a comma.

    Returns:
        Tuple[str, str]: Filename followed by display name. If no display name was provided, the filename will be used instead.
    """
    args = argument.split(",")
    if len(args) == 1:
        # Filename only
        return args[0], args[0], 0
    elif len(args) == 2:
        # Filename and display name
        return args[0], args[1], 0
    elif len(args) == 3:
        # Filename, display name, offset
        return args[0], args[1], float(args[2])
    else:
        # Something weird.
        print(f"Incorrect number of arguments in a pair '{argument}', expected FILENAME,DISPLAY_NAME")
        raise argparse.ArgumentError()

def custom_importer_pair(argument:str) -> MHPCSVImporter:
    """Parser that returns the importer.

    Args:
        argument (str): Argument to import.

    Returns:
        MHPCSVImporter: Importer matching the requests.
    """
    folder, display, offset = importer_name_pair(argument)
    try:
        importer = MHPCSVImporter(folder, offset, display)
    except Exception as e:
        print(e)
        raise argparse.ArgumentError()
    else:
        return importer

def a_training_tracker_importer_pair(argument:str) -> ATrainingTrackerCSVImporter:
    """Parser that returns the importer.

    Args:
        argument (str): Argument to import.

    Returns:
        ATrainingTrackerImporter: Importer matching the requests.
    """
    file, display, offset = importer_name_pair(argument)
    return ATrainingTrackerCSVImporter(file, offset, display)

def tcx_importer_pair(argument:str) -> FITImporter:
    """Parser that returns the importer.

    Args:
        argument (str): Argument to import.

    Returns:
        TCXImporter: Importer matching the requests.
    """
    file, display, offset = importer_name_pair(argument)
    return FITImporter(file, offset, display)

if __name__ == "__main__":
    # Extract command line arguments
    parser = argparse.ArgumentParser(
        description="Plots data from several power meters over time",
        conflict_handler="resolve",  # Cope with -h being used for host like mosquitto clients
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="Written by Jotham Gates and Oscar Varney for MHP, 2024",
    )
    parser.add_argument(
        "--title",
        help="Title to put on the figure",
        type=str,
        default="Comparison between power meters",
    )
    parser.add_argument(
        "-b",
        "--balance",
        help="Plot the left-right power balance instead of calculating individual left-right power for each side.",
        action="store_true",
    )
    add_time_args(parser)
    importer_group = parser.add_argument_group(
        "Importers",
        "Importers allow data in different formats to be processed."
    )
    importer_group.add_argument(
        "-c",
        "--custom",
        help="Folders containing data generated by log_power_meter.py. Data is formatted as a series of tuples of FOLDERNAME[,DISPLAY_NAME,OFFSET]]. If the display name is not provided, the folder name will be used and the offset set to 0. The offset (in seconds) defaults to 0 if not specified.",
        type=custom_importer_pair,
        nargs="+"
    )
    importer_group.add_argument(
        "-a",
        "--a-training-tracker",
        help="CSV file generated by the A Training Tracker App (or similar). Data is formatted as a series of sets of FOLDERNAME[,DISPLAY_NAME,[OFFSET]].  If the display name is not provided, the file name will be used and the offset set to 0. The offset (in seconds) defaults to 0 if not specified.",
        type=a_training_tracker_importer_pair,
        nargs="+"
    )
    importer_group.add_argument(
        "-f",
        "--fit-files",
        help="FIT file to import. Data is formatted as a series of sets of FOLDERNAME[,DISPLAY_NAME,[OFFSET]].  If the display name is not provided, the folder name will be used and the offset set to 0. The offset (in seconds) defaults to 0 if not specified.",
        type=tcx_importer_pair,
        nargs="+"
    )
    importer_group.add_argument(
        "--scale-a",
        help="Scalar value to scale the data from a training tracker. This is useful if the power meter logged through this is set to the incorrect crank length.",
        type=float,
        default=1
    )
    args = parser.parse_args()
    # Scale the A training tracker power as needed.
    a_training_tracker_importers = none_empty_list(args.a_training_tracker)
    for a in a_training_tracker_importers:
        a.set_scale(args.scale_a)

    importers: List[Importer] = none_empty_list(args.custom) + a_training_tracker_importers + none_empty_list(args.fit_files)
    if not len(importers):
        # No input files.
        print("No input files specified! Please try again using the '-c', '-a' or '-f' options, or run again using '--help' to show more information.")
    else:
        # We have some input files we can work with.
        load_all(importers)
        offset_all(importers, args.global_offset - importers[0].df["Unix Timestamp [s]"][0])
        truncate_times(importers, args.start, args.stop)
        plot_graph(importers, args.title, args.balance)
    